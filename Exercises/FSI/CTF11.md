# CTF #11: RSA

In this CTF, the nonce `698cf551a4ba42bf8d85a91ced155b3f` and the ciphertext `77a589e2e6f8657765f6a5aa7b` resulted from the encryption of a message using AES in CTR mode are given. The objective is to obtain the message without knowing the key.

## Ciphersuite vulnerability

The `cipherspec.py` script contains three functions for generating a key, encrypting a message, and decrypting a message using AES in CTR mode.
The problem is inside the key function:

```python
def gen():
	offset = 3 # Hotfix to make Crypto blazing fast!!
	key = bytearray(b'\x00'*(KEYLEN-offset))
	key.extend(os.urandom(offset))
	return bytes(key)
```

The key is generated by appending a random string of bytes to a string of null bytes.
This means that all the keys generated by this function will have the same 13 null bytes (if the length is 16 bytes), which reduces the number of possible keys from 2^128 to 2^24.

## Ciphersuite usage

This simple script allows to generate a key, encrypt a message, and decrypt a message like this, for example:

```python
nonce = binascii.unhexlify("698cf551a4ba42bf8d85a91ced155b3f")
message = "flag{test}".encode()
key = gen()

cipher = enc(key, message, nonce)
message = dec(key, cipher, nonce)

print(message.decode()) # flag{test}
```

## Vulnerability exploitation

Since the number of possible keys is reduced to 2^24, a brute force attack is perfectly feasible in this context.
Just generate a random key using the `key()` function, decrypt the message using `dec()`, and check if the message is the flag.

```python
nonce = binascii.unhexlify("698cf551a4ba42bf8d85a91ced155b3f")
crypt = binascii.unhexlify("77a589e2e6f8657765f6a5aa7bf6b9bdd2d04147b2d9")
key = gen()
decrypted = dec(key, crypt, nonce)
try:
    decrypted = decrypted.decode()
except UnicodeDecodeError:	# The "message" may not be a valid UTF-8 string
    continue
print("Key:", binascii.hexlify(key), "Message:", message)
```

## Automated exploitation

This process can be automated by wrapping the methodology mentioned above in a loop that breaks when the decoded message starts with "flag{".

```python
nonce = binascii.unhexlify("698cf551a4ba42bf8d85a91ced155b3f")
crypt = binascii.unhexlify("77a589e2e6f8657765f6a5aa7bf6b9bdd2d04147b2d9")

while True:
    key = gen()
    decrypted = dec(key, crypt, nonce)
    try:
        decrypted = decrypted.decode()
    except UnicodeDecodeError:	# The "message" may not be a valid UTF-8 string
	    continue
    print("Key:", binascii.hexlify(key), "Message:", message)
    if "flag" in decrypted:
        break
```

## Attack in practice

Paste the code above into the `cipherspec.py` script and run it in the terminal:
This process may take a while, up to a few minutes.

```bash
$ python3 cipherspec.py
[...]
Key: b'00000000000000000000000000d66a50' Message: flag{xfxhjtplwwxpsuks}
```

## Offset analysis: How big does the offset need to be for the attack be deemed infeasible?

It takes approximately 36 ms to try 2^10 keys:

```bash
$ time python3 cipherspec.py
real    0m0,036s
user    0m0,034s
sys     0m0,002s
```

So, for the attack to take up to 10 years (3,1536 x 10^11 ms), the attacker would need to try 8,97024 x 10^12 keys, which is equivalent to 2^44 keys. In conclusion, to make the attack infeasible, the offset should be at least 44 bits long (6 bytes).

## Nonce analysis: Using a one-byte private nonce does not improve security

Using a one-byte nonce introduces 2^8 possibilities per key, which is equivalent to 2^32 possibilities in total.
This is still a feasible number of possibilities to brute force; based on the measurements above, the attack would take up to 42 hours to complete.
